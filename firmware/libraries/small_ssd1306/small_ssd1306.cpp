#include <avr/pgmspace.h>
#include <util/delay.h>
#include <stdlib.h>


#include "small_ssd1306.h"

static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//uint8_t mosi, clock, dc, reset, cs, power, invert, orientation;

small_ssd1306::small_ssd1306(int8_t MOSI, int8_t CLOCK, int8_t DC, int8_t RESET,
			     int8_t CS, int8_t POWER, int8_t INVERT_SCREEN, int8_t ORIENTATION){
  mosi = MOSI;
  clock = CLOCK;
  dc = DC;
  reset = RESET;
  cs = CS;
  power = POWER;
  invert_screen = INVERT_SCREEN;
  orientation = ORIENTATION;
}

void small_ssd1306::on(void) {
  // set pin directions
  pinMode(reset, OUTPUT);
  pinMode(power, OUTPUT);

  digitalWrite(power, LOW); // turn oled on
  delay(10);
  SPI.begin();
  SPI.setClockDivider (SPI_CLOCK_DIV2); // 8 MHz

  digitalWrite(reset, HIGH);
  delay(1);
  digitalWrite(reset, LOW);
  delay(10);
  digitalWrite(reset, HIGH);
    // Init sequence for 128x32 OLED module
  spi_write_command(SSD1306_DISPLAYOFF);                    // 0xAE
  spi_write_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
  spi_write_command(0x80);                                  // the suggested ratio 0x80
  spi_write_command(SSD1306_SETMULTIPLEX);                  // 0xA8
  spi_write_command(0x1F);
  spi_write_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
  spi_write_command(0x0);                                   // no offset
  spi_write_command(SSD1306_SETSTARTLINE | 0x0);            // line #0
  spi_write_command(SSD1306_CHARGEPUMP);                    // 0x8D
  spi_write_command(0x14); //switchcap
  spi_write_command(SSD1306_MEMORYMODE);                    // 0x20
  spi_write_command(0x00);                                  // 0x0 act like ks0108
  spi_write_command(SSD1306_SEGREMAP | 0x1);
  spi_write_command(SSD1306_COMSCANDEC);
  spi_write_command(SSD1306_SETCOMPINS);                    // 0xDA
  spi_write_command(0x02);
  spi_write_command(SSD1306_SETCONTRAST);                   // 0x81
  spi_write_command(0x8F);
  spi_write_command(SSD1306_SETPRECHARGE);                  // 0xd9
  spi_write_command(0xF1); //switch cap
  spi_write_command(SSD1306_SETVCOMDETECT);                 // 0xDB
  spi_write_command(0x40);
  spi_write_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
  spi_write_command(SSD1306_NORMALDISPLAY);                 // 0xA6

  spi_write_command(SSD1306_DISPLAYON); //--turn on oled panel
}

void small_ssd1306::invert(void) {
  if(invert_screen) {
    invert_screen=0;
    spi_write_command(SSD1306_NORMALDISPLAY);
  } else {
    invert_screen=1;
    spi_write_command(SSD1306_INVERTDISPLAY);
  }
}

void small_ssd1306::update(void) {
  spi_write_command(SSD1306_COLUMNADDR);
  spi_write_command(0);   // Column start address (0 = reset)
  spi_write_command(127); // Column end address (127 = reset)

  spi_write_command(SSD1306_PAGEADDR);
  spi_write_command(0); // Page start address (0 = reset)
  spi_write_command(3); // Page end address


  for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
    digitalWrite(cs, HIGH);
    digitalWrite(dc, HIGH);
    digitalWrite(cs, LOW);
    (void)SPI.transfer(buffer[i]);
    digitalWrite(cs, HIGH);
  }
  // i wonder why we have to do this (check datasheet)
  //  if (SSD1306_LCDHEIGHT == 32) {
    // for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
    //   spi_write_data(0);
    // }
    //   //    }

}

void small_ssd1306::spi_write_command(uint8_t data) {
  digitalWrite(cs, HIGH);
  digitalWrite(dc, LOW);
  digitalWrite(cs, LOW);
  (void)SPI.transfer(data);
  digitalWrite(cs, HIGH);
}

void small_ssd1306::spi_write_data(uint8_t data) {
  digitalWrite(cs, HIGH);
  digitalWrite(dc, HIGH);
  digitalWrite(cs, LOW);
  (void)SPI.transfer(data);
  digitalWrite(cs, HIGH);
}
